module prettygen;

import prettyops;

string urlencode(string s) {
  return s
    .replace(`$`, "%24")
    .replace("&", "%26")
    .replace("+", "%2B")
    .replace(",", "%2C")
    .replace("/", "%2F")
    .replace(":", "%3A")
    .replace(";", "%3B")
    .replace("=", "%3D")
    .replace("?", "%3F")
    .replace("@", "%40")
    .replace("~", "%7E")
    .replace("%", "%25") // fuck you
  ;
}

import std.string;
import c.stdlib, c.poll, c.unistd;
string readback(string cmd, string data) {
  int x 2 hdl_sysward, hdl_selfward;
  pipe hdl_sysward; // self -> system()
  pipe hdl_selfward; // system() -> self
  "exec $(hdl_sysward[1])>&-; exec $(hdl_selfward[0])>&-; <&$(hdl_sysward[0]) $cmd >&$(hdl_selfward[1]) &"
    .toStringz().system();
  close hdl_sysward[0]; // read side
  close hdl_selfward[1]; // write side
  char[auto~] result;
  bool running = true;
  int fdslength = 2;
  while running {
    pollfd x 2 fds;
    fds[0].(fd, events) = (hdl_selfward[0], POLLIN);
    fds[1].(fd, events) = (hdl_sysward [1], POLLOUT);
    auto hits = poll(fds.ptr, fdslength, -1);
    if fds[0].revents & POLLHUP running = false;
    else {
      if fds[0].revents & POLLIN {
        char x 128 buf;
        auto size = read buf.(hdl_selfward[0], ptr, length);
        if (size > 0) {
          result ~= buf[0 .. size];
        }
      }
      if fds[1].revents & POLLOUT {
        auto res = write data.(hdl_sysward[1], ptr, length);
        if res < 0 {
          raise-error new Error "Write error";
        }
        data = data[res .. $];
        if !data.length { close hdl_sysward[1]; fdslength = 1; }
      }
    }
  }
  return result[];
}

import std.time, std.string, std.thread, std.file, gd;
extern(C) char* getenv(char*);
extern(C) FILE* stdout;
void main() {
  set-handler(Error err) {
    writeln "Content-type: text/html";
    writeln "";
    writeln "<html><head><title>Error!</title></head><body><h2>An error has occurred! </h2><h3>$err</h3></body></html>";
    invoke-exit "main-return";
  }
  define-exit "main-return" {
    return;
  }
  initOps();
  string queryString = CToString getenv toStringz "QUERY_STRING";
  string SERVER_NAME = CToString getenv toStringz "SERVER_NAME";
  string SERVER_PORT = CToString getenv toStringz "SERVER_PORT";
  string SCRIPT_NAME = CToString getenv toStringz "SCRIPT_NAME";
  Operator tree;
  int aa = 1, seed;
  (int, int) size = (512, 512);
  (int, int) depth;
  string treepath;
  int gifmode;
  void parseParams(string params) {
    int treeCost() {
      int recurse(Operator tree) {
        int res = 1;
        for auto ch <- tree.childs
          res += recurse ch;
        return res;
      }
      return recurse tree;
    }
    void initTree() {
      if (tree) return;
      initRNG seed;
      do {
        depth[0] = 2 + rand() % 4;
        depth[1] = depth[0] + rand() % 9;
        tree = genTree(depth);
      } while (treeCost() > 256) { } // reject trees that are too expensive
    }
    auto parts = params.split "&";
    for auto part <- parts {
      if (auto rest = part.startsWith "seed=") seed = rest.atoi();
      else if (auto rest = part.startsWith "size=") {
        if (rest.find("x") != -1) {
          size = (rest.split("x")[0].atoi(), rest.split("x")[1].atoi());
        } else {
          size = (rest.atoi() x 2);
        }
      }
      else if (auto rest = part.startsWith "hq") aa = 6;
      else if (auto rest = part.startsWith "aa=") aa = rest.atoi();
      else if (auto rest = part.startsWith "gif=") gifmode = rest.atoi();
      else if (auto rest = part.startsWith "treepath=") {
        if (!seed) raise-error new Error "Must define seed before treepath! ";
        initTree();
        (treepath, params) = rest.slice "&";
        string tp = treepath;
        while (tp.length) {
          (string step, tp) = tp.slice "-";
          tree = tree.childs[step.atoi()];
        }
      } else raise-error new Error "Unknown URL parameter: $part";
    }
    initTree();
  }
  string tree_graph() {
    int count;
    (string, string) recurse(Operator op, string treepath = "") {
      string nodename = "node_$(count++)";
      string res = "$nodename [label=\"$(op.name)\", fillcolor=\"#ffffff40\", style=filled]; \n";
      for (int i, Operator ch) <- zip(0..-1, op.childs) {
        auto chtup = recurse(ch, "$treepath$i-");
        res ~= chtup[0];
        res ~= "$nodename -> $(chtup[1]); \n";
      }
      return (res, nodename);
    }
    string res = recurse tree #[0];
    return "Digraph G { bgcolor = transparent; rankdir = LR; $res }";
    
  }
  if (auto rest = queryString.startsWith "basegraph") {
    writeln "Content-type: image/png";
    writeln "";
    fflush(stdout);
    
    seed = delegate int() { long l = µsec(); return *int* :&l; }();
    if (rest.startsWith "&") rest = rest[1..$];
    
    parseParams rest;
    
    auto pngdata = readback("dot -Tpng ", tree_graph());
    using new writer {
      hdl = 1;
      step byte[]:pngdata;
      close;
    }
    return;
  }
  if (auto rest = queryString.startsWith "picture") {
    writeln "Content-type: text/html";
    writeln "";
    
    seed = delegate int() { long l = µsec(); return *int* :&l; }();
    if (rest.startsWith "&") rest = rest[1..$];
    
    parseParams rest;
    
    writeln "<html>
    <head>
    <title>Image with seed $seed</title>
    </head>
    <body>
    Seed: $seed<br>
    <a href=\"?derivation&$rest\">Derivation</a>&nbsp;<a href=\"http://api.imgur.com/2/upload?url=$(\"http://$SERVER_NAME:$SERVER_PORT$SCRIPT_NAME?img&$rest\".urlencode())\">Upload to imgur</a><br />
    <img style=\"margin: 5px; border: solid 1px; \" src=\"?img&$rest\" /><br>
    </body>
    </html>";
    return;
  }
  string tree_info(string rest) {
    auto positions = readback("dot -Tdot", tree_graph()).split("\n");
    (int, int) graphsize;
    {
      auto szstr = positions[3].between("bb=\"", "\"").split(",");
      graphsize[0] = szstr[2].atoi();
      graphsize[1] = szstr[3].atoi();
    }
    (int, int) lookupNodePosition(string nodename) {
      for auto line <- positions {
        line = line.strip();
        if (line.startsWith nodename) {
          auto pos-str = line.between("pos=\"", "\"");
          (string a, string b) = pos-str.slice ",";
          return (a.atoi(), b.atoi());
        }
      }
      raise-error new Error "Internal error: no such node: $nodename";
    }
    char[auto~] extra_info;
    int count;
    string recurse(Operator op, string treepath) {
      string nodename = "node_$(count++)";
      auto pos = lookupNodePosition nodename;
      string extra;
      if (gifmode) extra = "&gif=$gifmode";
      extra_info ~= "
        <a href=\"?picture&seed=$seed&size=512&treepath=$treepath\">
        <img src=\"?img&seed=$seed&size=64&treepath=$treepath$extra\" style=\"position: absolute; left: $(pos[0] - 20)pt; top: $(graphsize[1] - pos[1] - 20)pt; \" />
        </a>";
      for (int i, Operator ch) <- zip(0..-1, op.childs) {
        string chname = recurse(ch, "$treepath$i-");
      }
      return nodename;
    }
    recurse (tree, treepath);
    string res = "
    <div style=\"position: relative; width: $(graphsize[0])pt; height: $(graphsize[1])pt; \">
    $(extra_info[])
    <img src=\"?basegraph&$rest\" style=\"position: absolute; z-index: 1; border: 1px solid; pointer-events: none; \"/>
    </div>";
    return res;
  }
  if (auto rest = queryString.startsWith "derivation") {
    writeln "Content-type: text/html";
    writeln "";
    
    seed = delegate int() { long l = µsec(); return *int* :&l; }();
    if (rest.startsWith "&") rest = rest[1..$];
    
    parseParams rest;
    
    writeln "<html>
    <head>
    <title>Derivation of seed $seed</title>
    </head>
    <body>
    <a href=\"?picture&$rest\">Back</a><br>
    $(tree_info(rest))
    <br>
    <img style=\"margin: 5px; border: solid 1px; \" src=\"?img$rest\" /><br>
    </body>
    </html>";
    return;
  }
  if (auto rest = queryString.startsWith "img") {
    seed = delegate int() { long l = µsec(); return *int* :&l; }();
    if (rest.startsWith "&") rest = rest[1..$];
    
    parseParams rest;
    
    float offs = randf();
    auto lp = new LoopPool 4;
    gdImagePtr genImage() {
      auto gdp = gdImageCreateTrueColor(size);
      auto start = sec();
      int stepsize = 32768 / size-of Element; // L1 size
      int aa2 = aa * aa;
      if (stepsize / aa2 #*aa2 != stepsize) {
        auto newstep = stepsize * aa2; // stepsize needs to be divisible by aa2, which may be npot
        while (newstep > stepsize && newstep & 1)
          newstep /= 2;
        stepsize = newstep;
        if (stepsize / aa2 #*aa2 != stepsize) {
          raise-error new Error "Huh. ";
        }
      }
      auto totalSteps = size[0] * size[1] * aa2;
      lp.runLoop(totalSteps / stepsize, delegate void(int i, thr) {
        i *= stepsize;
        auto linewidth = size[0] * aa2;
        int y = i / linewidth;
        i -= y * linewidth;
        int x = i / aa2;
        calcSegment(x, y, stepsize, size, aa, tree, gdp, offs);
      });
      auto stop = sec();
      // writeln "Time taken: $(float:(stop - start))";
      // auto hdl = fopen ("pretty.png", "w");
      // gdImagePng(gdp, c.gd.FILE*: hdl);
      // fclose hdl;
      return gdp;
    }
    if (gifmode) {
      writeln "Content-type: image/gif";
      writeln "";
      auto file = c.gd.FILE*:stdout;
      auto prev = genImage();
      gdImageGifAnimBegin(prev, file, 1, 0);
      gdImageGifAnimAdd(prev, file, 1, 0, 0, 100/gifmode, gdDisposalNone, gdImagePtr:0);
      for int i <- 1..gifmode {
        delta = i * 1f / gifmode;
        auto img = genImage();
        gdImageGifAnimAdd(img, file, 1, 0, 0, 100/gifmode, 0, prev);
        gdImageDestroy prev;
        prev = img;
      }
      gdImageGifAnimEnd(file);
      gdImageDestroy prev;
    } else {
      writeln "Content-type: image/png";
      writeln "";
      gdImagePng(auto gdp = genImage(), c.gd.FILE*:stdout);
      gdImageDestroy gdp;
    }
    return;
  }
  
  int count = 64;
  if (auto rest = queryString.startsWith "count=") { (string c, queryString) = rest.slice "&"; count = c.atoi(); }
  writeln "Content-type: text/html";
  writeln "";
  string img_gen() {
    char[auto~] res;
    long l = µsec();
    initRNG *int*: &l;
    for (int i = 0; i < count; ++i) {
      auto newseed = rand();
      res ~= "<div class=\"gallery_pic\"><a href=\"?picture&seed=$newseed&$queryString\"><img width=128 height=128 src=\"?img&seed=$newseed&size=128\" /></a><br></div>";
    }
    return res[];
  }
  writeln "
  <html>
  <head>
  <title>Picgen</title>
  <style type=\"text/css\">
    .gallery_pic {margin: 4px; float: left; border: 1px solid; }
  </style>
  </head>
  <body>
  Image!<br>
  <div style=\"position: relative; width: $((128+16)*7)px; \">
  $(img_gen())
  </div>
  </body>
  </html>
  ";
}
